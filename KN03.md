# KN03 - Infrastruktur Automatisierung


## ðŸŸ¢ 1. Teil-Challenge - Aufsetzen der EC2-Instanz mit IaC-Code - AWS LEARNER LAB


1. Als erstes habe ich die EC2 Instance erstellt :

![](Bilder/02.png)
![](05.png)

So sieht der Cloud-Init Code aus mit der ich die Instance gestartet habe:

```
#cloud-config
packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg-agent
  - software-properties-common
# Sorgt dafÃ¼r, dass auf dem Zielsystem das IPv4-Forwarding aktiviert wird, was hÃ¤ufig auf Routern oder in Netzwerkkonfigurationen benÃ¶tigt wird, die als Gateway dienen
write_files:
  - path: /etc/sysctl.d/enabled_ipv4_forwarding.conf
    content: |
      net.ipv4.conf.all.forwarding=1
groups:
  - docker
# Install Docker and Podman: fixieren auf stabile Versionen
runcmd:
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
  - add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
  - apt-get update -y
  - apt-get install -y docker-ce docker-ce-cli containerd.io
  - systemctl start docker
  - systemctl enable docker
  - apt-get install podman -y
  - systemctl start podman
  - systemctl enable podman
  - usermod -aG docker ubuntu
```



2. Hier sieht man die erfolgreiche Verbindung mit dem SSH schlÃ¼ssel:

![](./Bilder/01.png)


`docker --version` und `systemctl sttus docker` ausgefÃ¼hrt:
![](Bilder/03.png)

`podman --version` und `systemctl status podman` ausgefÃ¼hrt:
![](Bilder/04.png)

---


## ðŸŸ¢ 2. Teil-Challenge - OCI-Images, Container und Registry - BASICS



1. Hello-World
![](Bilder/06.png)
- Ergebnis: Docker lÃ¤uft korrekt
- Container wurde aus dem offiziellen Image gestartet
- Testausgabe bestÃ¤tigt funktionierende Installation



2. Docker image
![](Bilder/07.png)
ErklÃ¤rung:

- `docker image ls`: zeigt alle heruntergeladenen Images
- `docker ps`: zeigt aktuell **laufende** Container
- `docker ps -a`: zeigt **alle** Container (inkl. beendeter)


3. NGINX
![](Bilde/08.png)
ErklÃ¤rung:

- `-d`: startet den Container im Hintergrund (detached mode)
- `-p 8080:80`: mappt Port 80 im Container auf Port 8080 auf dem Host
- `nginx`: verwendet das Image `nginx:latest` aus der offiziellen Docker Registry



3. Am anfang hat es nicht funktioniert, weil ich den port 8080 in meiner Sciherheitsgruppe nicht als regel erstellt habe die verbindung durch zu lassen:

![](Bilder/10.png)
![](Bilder/09.png)

4. Die Verbindung mit dem NGINX Server hat funktioniert!:

![](Bilder/11.png)


### ðŸ“Œ **Grundlegende Docker-Befehle**

| Befehl             | ErklÃ¤rung                                     |
| ------------------ | --------------------------------------------- |
| `docker run`       | Startet einen neuen Container aus einem Image |
| `docker ps`        | Zeigt aktuell laufende Container              |
| `docker ps -a`     | Zeigt alle Container (auch bereits beendete)  |
| `docker stop <ID>` | Stoppt einen laufenden Container              |
| `docker rm <ID>`   | LÃ¶scht einen gestoppten Container             |
| `docker image ls`  | Listet lokal gespeicherte Images auf          |



### Docker vs. Virtuelle Maschine (VM)**

| **Docker Container**                        | **Virtuelle Maschine (VM)**                      |
| ------------------------------------------- | ------------------------------------------------ |
| LÃ¤uft auf dem Host-Kernel (leichtgewichtig) | Hat ein eigenes Betriebssystem (schwergewichtig) |
| Startet in Sekunden                         | Startet in Minuten                               |
| Teilt Ressourcen effizient                  | Reserviert Ressourcen fix                        |
| Weniger Overhead                            | Mehr Overhead durch Hypervisor                   |
| Isoliert Ã¼ber Namespaces                    | Isoliert durch Virtualisierungsschicht           |


### **Isolation von Containern â€“ Vorteile**

- Jeder Container ist **isoliert** vom Host und von anderen Containern.

- Dadurch entstehen:
    
    - **Mehr Sicherheit**
        
    - **Weniger Konflikte** bei AbhÃ¤ngigkeiten (z.â€¯B. verschiedene Python-Versionen)
        
    - **Bessere PortabilitÃ¤t** â€“ ein Container lÃ¤uft Ã¼berall gleich
        
    - **Schnelleres Debugging und Testing**




### Bonus-Credit: Zugriff auf laufenden NGINX-Webserver

Ich habe den NGINX-Container erfolgreich mit folgendem Befehl gestartet:

`docker run -d -p 8080:80 nginx`

![](Bilder/13.png)
![](Bilder/12.png)

----

## ðŸŸ¢ 3. Teil-Challenge - OCI-Images mit Docker - RUN & ADMINISTRATION

### Ziel der Challenge

- MariaDB-Container mit Docker starten
- Daten persistent speichern mit Docker Volume (Bind Mount)
- Remote-Zugriff per HeidiSQL einrichten
- Zugriff Ã¼ber Port 3306 erlauben
- Nachweis: Datenbank bleibt auch nach Container-Neustart erhalten

---

### Setup & Konfiguration

#### 1. MariaDB-Container starten

````
docker run -d --name mariadb \
  -e MYSQL_ROOT_PASSWORD=12345 \
  -p 3306:3306 \
  -v ~/data/mysql:/var/lib/mysql \
  mariadb
````

![alt text](image_115.png)

### Daten persistieren mit Docker Volume

#### Was macht -v ~/data/mysql:/var/lib/mysql?

- ~/data/mysql â†’ Ordner auf dem Host-System (EC2)
- /var/lib/mysql â†’ Speicherort der Datenbank im Container

Docker verknÃ¼pft beides. Alle Daten werden auÃŸerhalb des Containers gespeichert = persistente Speicherung.

#### Warum war docker volume create nicht nÃ¶tig?

| Typ              | Beschreibung                  | Beispiel                         |
| ---------------- | ----------------------------- | -------------------------------- |
| **Named Volume** | Von Docker verwaltet          | `-v mariadb_data:/var/lib/mysql` |
| **Bind Mount**   | Zeigt auf lokalen Host-Ordner | `-v ~/data/mysql:/var/lib/mysql` |


Bind Mounts werden automatisch erstellt, wenn sie noch nicht existieren.

#### Hinweis zu Berechtigungen

Docker kann den Ordner mit Root-Rechten erstellen. Beim LÃ¶schen war daher sudo nÃ¶tig:

````
sudo rm -rf ~/data/mysql`
````

### Zugriff per Remote-Verbindung ermÃ¶glichen

#### 1. In den Container einloggen
````
docker exec -it mariadb bash
````

#### 2. In MariaDB einloggen
````
mariadb -u root -p
````

![alt text](image_116.png)

#### 3. Remote-Zugriff aktivieren

````
ALTER USER 'root'@'%' IDENTIFIED BY '12345';
FLUSH PRIVILEGES;
````
![alt text](image_117.png)

### AWS Security Group

In der EC2-Konsole â†’ Sicherheitsgruppe â†’ Inbound Rules:

| Typ        | Protokoll | Port | Quelle (Source) |
| ---------- | --------- | ---- | --------------- |
| Custom TCP | TCP       | 3306 | Deine-IP/32     |

![alt text](image_118.png)

### Verbindung mit HeidiSQL

Verbindungseinstellungen:

- Verbindungstyp: MariaDB (TCP/IP)
- Hostname/IP: Public IP der EC2
- Benutzer: root
- Passwort: 12345
- Port: 3306

### Test-Datenbank anlegen

````
CREATE DATABASE M169_KN03_VUK;
````
![alt text](image_113.png)
![alt text](image_114.png)

### Persistenz nach Neustart

Nach einem Neustart:

````
docker stop mariadb
docker rm mariadb
docker run -d --name mariadb \
  -e MYSQL_ROOT_PASSWORD=12345 \
  -p 3306:3306 \
  -v ~/data/mysql:/var/lib/mysql \
  mariadb
````

![alt text](image_119.png)

In HeidiSQL: M169_KN03_KON ist noch vorhanden.`

![alt text](image_120.png)

### Begriff: Was bedeutet â€žPersistente Datenâ€œ?

â€žPersistente Datenâ€œ bleiben dauerhaft gespeichert, auch wenn ein Docker-Container gelÃ¶scht oder neugestartet wird.

In dieser Challenge wurde das durch ein sogenanntes Bind Mount Volume umgesetzt:

````
-v ~/data/mysql:/var/lib/mysql

````
Alle Daten der MariaDB-Datenbank werden in den Ordner ~/data/mysql auÃŸerhalb des Containers gespeichert.
Dadurch gehen sie nicht verloren, wenn der Container entfernt wird.
Das ist besonders wichtig fÃ¼r produktive Systeme mit echten Benutzerdaten.

----

## 4. Teil-Challenge - OCI-Images mit Docker - BUILD & CUSTOMIZATION


### Ziel der Challenge

Eigene OCI-Images erstellen und verÃ¤ndern

Manuelle Container-Anpassung und Commit

Automatisiertes Image-Building per Dockerfile

Apache-Webserver + cowsay + fortune integrieren

CMD anpassen, sodass cowsay automatisch startet

âœ… Variante 1: Manuelle Anpassung und Commit

1. Ubuntu-Container starten

docker run -it --name mein-ubuntu ubuntu bash

ðŸ“¸ Screenshot 1: Container mit Ubuntu gestartet (bash-Prompt sichtbar)

2. Im Container: Pakete installieren

apt update
apt install -y cowsay fortune

ðŸ“¸ Screenshot 2: cowsay und fortune werden erfolgreich installiert

3. Programme testen

/usr/games/cowsay "Hello"
/usr/games/fortune | /usr/games/cowsay

ðŸ“¸ Screenshot 3: ASCII-Cow gibt fortune-Spruch aus

4. Container verlassen

exit

5. Commit: Image speichern

docker commit mein-ubuntu ubuntu-cowsay:1.0

ðŸ“¸ Screenshot 4: docker commit mit Image-ID erfolgreich

6. Neues Image starten & testen

docker run -it ubuntu-cowsay:1.0 bash
/usr/games/cowsay "Ich bin da!"

ðŸ“¸ Screenshot 5: neuer Container zeigt cowsay funktioniert weiterhin

âœ… Variante 2: Dockerfile und automatischer Build

1. Verzeichnis erstellen und Dateien anlegen

mkdir apache-cowsay && cd apache-cowsay
nano Dockerfile

Inhalt Dockerfile (Teil 1: Apache + HTML)

FROM ubuntu:24.04

RUN apt update && apt install -y \
    apache2 \
    cowsay \
    fortune

COPY index.html /var/www/html/index.html

EXPOSE 80
CMD ["apache2ctl", "-D", "FOREGROUND"]

ðŸ“¸ Screenshot 6: Dockerfile Inhalt

index.html erstellen

echo "<h1>Hallo, ich bin KÃ¶nig ðŸ‘‘</h1>" > index.html

2. Image bauen

docker build -t apache-cowsay:1.0 .

ðŸ“¸ Screenshot 7: erfolgreicher docker build

3. Container starten

docker run -d --name webserver -p 8080:80 apache-cowsay:1.0

ðŸ“¸ Screenshot 8: docker ps mit laufendem Webserver auf Port 8080

4. Webseite testen

curl http://localhost:8080

Oder im Browser:

http://<DEINE_EC2_PUBLIC_IP>:8080

ðŸ“¸ Screenshot 9: Webseite zeigt HTML-Text aus index.html

âœ… Dockerfile anpassen: cowsay automatisch starten

Dockerfile Ã¤ndern:

FROM ubuntu:24.04

RUN apt update && apt install -y \
    cowsay \
    fortune

CMD ["bash", "-c", "/usr/games/fortune | /usr/games/cowsay"]

ðŸ“¸ Screenshot 10: Neues Dockerfile mit CMD fÃ¼r cowsay

Neues Image bauen

docker build -t cowsay-auto:1.0 .

ðŸ“¸ Screenshot 11: Build von cowsay-auto:1.0 erfolgreich

Image testen

docker run cowsay-auto:1.0

ðŸ“¸ Screenshot 12: Ausgabe von fortune + cowsay automatisch bei Start