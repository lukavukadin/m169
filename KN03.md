# KN03 - Infrastruktur Automatisierung


## üü¢ 1. Teil-Challenge - Aufsetzen der EC2-Instanz mit IaC-Code - AWS LEARNER LAB


1. Als erstes habe ich die EC2 Instance erstellt :

![](Bilder/02.png)
![](05.png)

So sieht der Cloud-Init Code aus mit der ich die Instance gestartet habe:

```
#cloud-config
packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg-agent
  - software-properties-common
# Sorgt daf√ºr, dass auf dem Zielsystem das IPv4-Forwarding aktiviert wird, was h√§ufig auf Routern oder in Netzwerkkonfigurationen ben√∂tigt wird, die als Gateway dienen
write_files:
  - path: /etc/sysctl.d/enabled_ipv4_forwarding.conf
    content: |
      net.ipv4.conf.all.forwarding=1
groups:
  - docker
# Install Docker and Podman: fixieren auf stabile Versionen
runcmd:
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
  - add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
  - apt-get update -y
  - apt-get install -y docker-ce docker-ce-cli containerd.io
  - systemctl start docker
  - systemctl enable docker
  - apt-get install podman -y
  - systemctl start podman
  - systemctl enable podman
  - usermod -aG docker ubuntu
```



2. Hier sieht man die erfolgreiche Verbindung mit dem SSH schl√ºssel:

![](./Bilder/01.png)


`docker --version` und `systemctl sttus docker` ausgef√ºhrt:
![](Bilder/03.png)

`podman --version` und `systemctl status podman` ausgef√ºhrt:
![](Bilder/04.png)

---


## üü¢ 2. Teil-Challenge - OCI-Images, Container und Registry - BASICS



1. Hello-World
![](Bilder/06.png)
- Ergebnis: Docker l√§uft korrekt
- Container wurde aus dem offiziellen Image gestartet
- Testausgabe best√§tigt funktionierende Installation



2. Docker image
![](Bilder/07.png)
Erkl√§rung:

- `docker image ls`: zeigt alle heruntergeladenen Images
- `docker ps`: zeigt aktuell **laufende** Container
- `docker ps -a`: zeigt **alle** Container (inkl. beendeter)


3. NGINX
![](Bilde/08.png)
Erkl√§rung:

- `-d`: startet den Container im Hintergrund (detached mode)
- `-p 8080:80`: mappt Port 80 im Container auf Port 8080 auf dem Host
- `nginx`: verwendet das Image `nginx:latest` aus der offiziellen Docker Registry



3. Am anfang hat es nicht funktioniert, weil ich den port 8080 in meiner Sciherheitsgruppe nicht als regel erstellt habe die verbindung durch zu lassen:

![](Bilder/10.png)
![](Bilder/09.png)

4. Die Verbindung mit dem NGINX Server hat funktioniert!:

![](Bilder/11.png)


### üìå **Grundlegende Docker-Befehle**

| Befehl             | Erkl√§rung                                     |
| ------------------ | --------------------------------------------- |
| `docker run`       | Startet einen neuen Container aus einem Image |
| `docker ps`        | Zeigt aktuell laufende Container              |
| `docker ps -a`     | Zeigt alle Container (auch bereits beendete)  |
| `docker stop <ID>` | Stoppt einen laufenden Container              |
| `docker rm <ID>`   | L√∂scht einen gestoppten Container             |
| `docker image ls`  | Listet lokal gespeicherte Images auf          |



### Docker vs. Virtuelle Maschine (VM)**

| **Docker Container**                        | **Virtuelle Maschine (VM)**                      |
| ------------------------------------------- | ------------------------------------------------ |
| L√§uft auf dem Host-Kernel (leichtgewichtig) | Hat ein eigenes Betriebssystem (schwergewichtig) |
| Startet in Sekunden                         | Startet in Minuten                               |
| Teilt Ressourcen effizient                  | Reserviert Ressourcen fix                        |
| Weniger Overhead                            | Mehr Overhead durch Hypervisor                   |
| Isoliert √ºber Namespaces                    | Isoliert durch Virtualisierungsschicht           |


### **Isolation von Containern ‚Äì Vorteile**

- Jeder Container ist **isoliert** vom Host und von anderen Containern.

- Dadurch entstehen:
    
    - **Mehr Sicherheit**
        
    - **Weniger Konflikte** bei Abh√§ngigkeiten (z.‚ÄØB. verschiedene Python-Versionen)
        
    - **Bessere Portabilit√§t** ‚Äì ein Container l√§uft √ºberall gleich
        
    - **Schnelleres Debugging und Testing**




### Bonus-Credit: Zugriff auf laufenden NGINX-Webserver

Ich habe den NGINX-Container erfolgreich mit folgendem Befehl gestartet:

`docker run -d -p 8080:80 nginx`

![](Bilder/13.png)
![](Bilder/12.png)

----

## üü¢ 3. Teil-Challenge - OCI-Images mit Docker - RUN & ADMINISTRATION

### Ziel der Challenge

- MariaDB-Container mit Docker starten
- Daten persistent speichern mit Docker Volume (Bind Mount)
- Remote-Zugriff per HeidiSQL einrichten
- Zugriff √ºber Port 3306 erlauben
- Nachweis: Datenbank bleibt auch nach Container-Neustart erhalten

---

### Setup & Konfiguration

#### 1. MariaDB-Container starten

````
docker run -d --name mariadb \
  -e MYSQL_ROOT_PASSWORD=12345 \
  -p 3306:3306 \
  -v ~/data/mysql:/var/lib/mysql \
  mariadb
````

![alt text](image_115.png)

### Daten persistieren mit Docker Volume

#### Was macht -v ~/data/mysql:/var/lib/mysql?

- ~/data/mysql ‚Üí Ordner auf dem Host-System (EC2)
- /var/lib/mysql ‚Üí Speicherort der Datenbank im Container

Docker verkn√ºpft beides. Alle Daten werden au√üerhalb des Containers gespeichert = persistente Speicherung.

#### Warum war docker volume create nicht n√∂tig?

| Typ              | Beschreibung                  | Beispiel                         |
| ---------------- | ----------------------------- | -------------------------------- |
| **Named Volume** | Von Docker verwaltet          | `-v mariadb_data:/var/lib/mysql` |
| **Bind Mount**   | Zeigt auf lokalen Host-Ordner | `-v ~/data/mysql:/var/lib/mysql` |


Bind Mounts werden automatisch erstellt, wenn sie noch nicht existieren.

#### Hinweis zu Berechtigungen

Docker kann den Ordner mit Root-Rechten erstellen. Beim L√∂schen war daher sudo n√∂tig:

````
sudo rm -rf ~/data/mysql`
````

### Zugriff per Remote-Verbindung erm√∂glichen

#### 1. In den Container einloggen
````
docker exec -it mariadb bash
````

#### 2. In MariaDB einloggen
````
mariadb -u root -p
````

![alt text](image_116.png)

#### 3. Remote-Zugriff aktivieren

````
ALTER USER 'root'@'%' IDENTIFIED BY '12345';
FLUSH PRIVILEGES;
````
![alt text](image_117.png)

### AWS Security Group

In der EC2-Konsole ‚Üí Sicherheitsgruppe ‚Üí Inbound Rules:

| Typ        | Protokoll | Port | Quelle (Source) |
| ---------- | --------- | ---- | --------------- |
| Custom TCP | TCP       | 3306 | Deine-IP/32     |

![alt text](image_118.png)

### Verbindung mit HeidiSQL

Verbindungseinstellungen:

- Verbindungstyp: MariaDB (TCP/IP)
- Hostname/IP: Public IP der EC2
- Benutzer: root
- Passwort: 12345
- Port: 3306

### Test-Datenbank anlegen

````
CREATE DATABASE M169_KN03_VUK;
````
![alt text](image_113.png)
![alt text](image_114.png)

### Persistenz nach Neustart

Nach einem Neustart:

````
docker stop mariadb
docker rm mariadb
docker run -d --name mariadb \
  -e MYSQL_ROOT_PASSWORD=12345 \
  -p 3306:3306 \
  -v ~/data/mysql:/var/lib/mysql \
  mariadb
````

![alt text](image_119.png)

In HeidiSQL: M169_KN03_KON ist noch vorhanden.`

![alt text](image_120.png)

### Begriff: Was bedeutet ‚ÄûPersistente Daten‚Äú?

‚ÄûPersistente Daten‚Äú bleiben dauerhaft gespeichert, auch wenn ein Docker-Container gel√∂scht oder neugestartet wird.

In dieser Challenge wurde das durch ein sogenanntes Bind Mount Volume umgesetzt:

````
-v ~/data/mysql:/var/lib/mysql

````
Alle Daten der MariaDB-Datenbank werden in den Ordner ~/data/mysql au√üerhalb des Containers gespeichert.
Dadurch gehen sie nicht verloren, wenn der Container entfernt wird.
Das ist besonders wichtig f√ºr produktive Systeme mit echten Benutzerdaten.

----